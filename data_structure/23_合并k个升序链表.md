# 23. 合并K个升序链表
## 题目描述
给你一个链表数组，每个链表都已经按升序排列。

请你将所有链表合并到一个升序链表中，返回合并后的链表。

## Analysis

### 基础解法：暴力合并

这种方法每次都遍历所有链表头节点，找到最小值进行合并。

```cpp
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* mergeKLists(vector<ListNode*>& lists) {
        // Create a dummy head node to simplify the merge process
        ListNode head = ListNode();
        ListNode* end = &head;  // Pointer to the last node in the merged list
        
        while(true){
            // Find the currently minimum node among all list heads
            int min_id = -1;  // Index of the list with minimum head value
            
            // Iterate through all lists to find the minimum head value
            for(int i = 0; i < lists.size(); i++){
                if(lists[i] == nullptr) continue;  // Skip empty lists
                
                // Update min_id if current list has smaller head value
                if(min_id == -1 || lists[i]->val < lists[min_id]->val) {
                    min_id = i;
                }
            }
            
            // If no valid list found, all lists are empty, break the loop
            if(min_id == -1) break;
            
            // Append the minimum node to the merged list
            end->next = lists[min_id];
            end = lists[min_id];
            
            // Move the head of the selected list to the next node
            lists[min_id] = lists[min_id]->next;
        }
        
        // Ensure the last node points to null
        end->next = nullptr;
        
        // Return the merged list (skip the dummy head)
        return head.next;
    }
};
```

### 复杂度分析：

**时间复杂度：O(k × N)**
- k：链表的数量
- N：所有链表中节点的总数
- 每次需要遍历k个链表头找最小值，总共需要处理N个节点
- 因此总时间复杂度为 O(k × N)

**空间复杂度：O(1)**
- 只使用了常数个额外变量（head, end, min_id等）
- 没有使用额外的数据结构存储节点

### 算法特点：
- **优点**：实现简单，空间效率高
- **缺点**：时间效率不高，每次都要遍历所有链表头部

这种暴力方法适合链表数量较少的情况，当k很大时效率会显著下降。

## 优化解法：分治合并

分治法的核心思想是将k个链表两两合并，递归地减少问题规模，最终合并成一个链表。

```cpp
class Solution {
public:
    // Helper function: merge two sorted linked lists
    ListNode* mergeTwoLists(ListNode *a, ListNode *b) {
        // Base case: if one list is empty, return the other
        if ((!a) || (!b)) return a ? a : b;
        
        // Create dummy head for easier manipulation
        ListNode head, *tail = &head, *aPtr = a, *bPtr = b;
        
        // Merge two lists by comparing values
        while (aPtr && bPtr) {
            if (aPtr->val < bPtr->val) {
                tail->next = aPtr; 
                aPtr = aPtr->next;
            } else {
                tail->next = bPtr; 
                bPtr = bPtr->next;
            }
            tail = tail->next;
        }
        
        // Append remaining nodes from non-empty list
        tail->next = (aPtr ? aPtr : bPtr);
        return head.next;
    }

    // Divide and conquer: merge lists in range [l, r]
    ListNode* merge(vector<ListNode*> &lists, int l, int r) {
        // Base case: single list
        if (l == r) return lists[l];    // in the end, return the left node
        
        // Base case: invalid range
        if (l > r) return nullptr;
        
        // Divide: split the range into two halves
        int mid = (l + r) >> 1;
        
        // Conquer: recursively merge left and right halves
        return mergeTwoLists(merge(lists, l, mid), merge(lists, mid + 1, r));
    }

    // Main function: start divide and conquer process
    ListNode* mergeKLists(vector<ListNode*>& lists) {
        if (lists.empty()) return nullptr;
        return merge(lists, 0, lists.size() - 1);
    }
};
```

### 复杂度分析：

**时间复杂度：O(N × log k)**
- N：所有链表中节点的总数
- k：链表的数量
- 分治树的深度为 log k
- 每一层都需要处理所有N个节点
- 因此总时间复杂度为 O(N × log k)

**空间复杂度：O(log k)**
- 递归调用栈的深度为 log k
- 每层递归只使用常数空间

### 算法优势：

1. **时间效率提升**：
   - 从 O(k × N) 优化到 O(N × log k)
   - 当k很大时，log k << k，性能提升显著

2. **分治思想**：
   - 将复杂问题分解为简单的两两合并
   - 利用递归结构，代码简洁优雅

3. **复用性**：
   - `mergeTwoLists` 函数可以独立使用
   - 遵循单一职责原则

### 算法过程示例：
```
假设有4个链表 [L1, L2, L3, L4]

第1层: L1+L2 → M1,  L3+L4 → M2
第2层: M1+M2 → 最终结果

分治树结构：
       merge(0,3)
      /          \
  merge(0,1)    merge(2,3)
   /    \        /    \
  L1    L2      L3    L4
```

这种分治方法在处理大量链表时效率远超暴力方法，是该问题的最优解之一。


