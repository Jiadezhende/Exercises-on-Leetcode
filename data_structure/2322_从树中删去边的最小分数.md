# 2322. 从树中删去边的最小分数
## 题目描述
存在一棵无向连通树，树中有编号从 0 到 n - 1 的 n 个节点， 以及 n - 1 条边。

给你一个下标从 0 开始的整数数组 `nums` ，长度为 n ，其中 nums[i] 表示第 i 个节点的值。另给你一个二维整数数组 `edges` ，长度为 n - 1 ，其中 `edges[i] = [ai, bi]` 表示树中存在一条位于节点 ai 和 bi 之间的边。

删除树中两条 不同 的边以形成三个连通组件。对于一种删除边方案，定义如下步骤以计算其分数：

分别获取三个组件 每个 组件中所有节点值的异或值。
最大 异或值和 最小 异或值的 差值 就是这一种删除边方案的分数。
例如，三个组件的节点值分别是：`[4,5,7]`、`[1,9]` 和 `[3,3,3]` 。三个异或值分别是 `4 ^ 5 ^ 7 = 6`、`1 ^ 9 = 8` 和 `3 ^ 3 ^ 3 = 3` 。最大异或值是 8 ，最小异或值是 3 ，分数是 8 - 3 = 5 。
返回在给定树上执行任意删除边方案可能的最小分数。

## Analysis

***Firstlt, we defined some global variables:***
```c++
int n; // number of nodes
vector<vector<int>> g;  // adjacency list representation of the tree
vector<int> nums;   // value of each node
vector<int> subtreeXor; // xor of all subtrees rooted at each node
vector<int> parent; // parent of each node in the tree
int res = INT_MAX;  // to store the minimum score
```

***Then, let's consider the xor operation. ***
The feature of exclusive or (XOR): 
for sets of integers A and B, A contains B, the following equation holds:
`xor(A-B)=A^B` 
Thus, we can calculate the xor of any component by calculating the xor results of two trees, one of which contains the other.
We use DFS to calculate the xor of all the subtrees rooted at each node. 
```c++
// calculate xor of all subtrees rooted at each node,
// and by the way, store the parent node of each.
int dfs(int u, int p) {
    parent[u] = p;
    int xor_val = nums[u];
    for (int v : g[u]) {
        if (v == p) continue; //jump over the parent node
        xor_val ^= dfs(v, u); //recursive call to calculate xor of subtree rooted at v
    }
    subtreeXor[u] = xor_val;
    return xor_val;
}
```

***Next, we should test all the 2-edge deletion cases and find the minimum score.***
Confirm an edge to be deleted, marked as `u-v`.
Then, consider 2 possiblities:
1. delete an edge in `component v`.(which means node v is contained in the component)
2. delete an edge in `component u`.

For the first case:
```c++
// test all possible edges in component v and calculate the score
/**
    * @param u: current node
    * @param total_xor: the xor value of the tree
    * @param xor_val: the xor value of subtree rooted at the node v
**/
void dfs_sub1(int u, int total_xor, int xor_val){
    int x=total_xor^xor_val;
    int y=subtreeXor[u]^xor_val;
    int z=subtreeXor[u];
    int maxv = max({x, y, z});
    int minv = min({x, y, z});
    res = min(res, maxv - minv);

    for(int v:g[u]){
        if (v == parent[u]) continue;
        dfs_sub1(v,total_xor,xor_val);   // dfs
    }
}
```

For the second case:
We need a tool function to test all the edges in a subtree:
```c++
/**
    * @param u: current node
    * @param total_xor: the xor value of the tree
    * @param xor_val: the xor value of subtree rooted at the node v
**/
void dfs_sub2(int u, int total_xor, int xor_val){
    int x=total_xor^xor_val^subtreeXor[u];
    int y=xor_val;
    int z=subtreeXor[u];
    int maxv = max({x, y, z});
    int minv = min({x, y, z});
    res = min(res, maxv - minv);

    for(int v:g[u]){
        if (v == parent[u]) continue;
        dfs_sub2(v, total_xor, xor_val);    // dfs
    }
}
```
In the main function, we test the unvisited son of all the ancestor nodes of node v:
```c++
while(parent[case2]>=0){
    int temp=case2;
    case2=parent[case2];
    for(int v:g[case2]){
        if (v == parent[case2]||v==temp) continue; //jump over the parent node and visited node
        dfs_sub2(v, total_xor, xor1);
    }
}
```

## The comple code:
```c++
class Solution {
public:
    vector<vector<int>> g;  // adjacency list representation of the tree
    vector<int> nums;   // value of each node
    vector<int> subtreeXor; // xor of all subtrees rooted at each node
    vector<int> parent; // parent of each node in the tree
    int res = INT_MAX;  // to store the minimum score

    // calculate xor of all subtrees rooted at each node,
    // and by the way, store the parent node of each.
    int dfs(int u, int p) {
        parent[u] = p;
        int xor_val = nums[u];
        for (int v : g[u]) {
            if (v == p) continue; //jump over the parent node
            xor_val ^= dfs(v, u); //recursive call to calculate xor of subtree rooted at v
        }
        subtreeXor[u] = xor_val;
        return xor_val;
    }
    // test all possible edges in component v and calculate the score
    /**
        * @param u: current node
        * @param total_xor: the xor value of the tree
        * @param xor_val: the xor value of subtree rooted at the node v
    **/
    void dfs_sub1(int u, int total_xor, int xor_val){
        int x=total_xor^xor_val;
        int y=subtreeXor[u]^xor_val;
        int z=subtreeXor[u];
        int maxv = max({x, y, z});
        int minv = min({x, y, z});
        res = min(res, maxv - minv);
        if(res==0) return;

        for(int v:g[u]){
            if (v == parent[u]) continue;
            dfs_sub1(v,total_xor,xor_val);   // dfs
            if(res==0) return;
        }
    }
    /**
        * @param u: current node
        * @param total_xor: the xor value of the tree
        * @param xor_val: the xor value of subtree rooted at the node v
    **/
    void dfs_sub2(int u, int total_xor, int xor_val){
        int x=total_xor^xor_val^subtreeXor[u];
        int y=xor_val;
        int z=subtreeXor[u];
        int maxv = max({x, y, z});
        int minv = min({x, y, z});
        res = min(res, maxv - minv);
        if(res==0) return;

        for(int v:g[u]){
            if (v == parent[u]) continue;
            dfs_sub2(v, total_xor, xor_val);    // dfs
            if(res==0) return;
        }
    }

    int minimumScore(vector<int>& nums_, vector<vector<int>>& edges) {
        // initialize the graph and other variables
        int n = nums_.size();
        
        // Edge case: if n < 3, we can't form 3 components
        if (n < 3 || edges.size() < 2) return 0;
        
        g.assign(n, vector<int>());
        subtreeXor.assign(n, 0); //0 will not affect the xor value
        parent.assign(n, -1); // -1 means no parent

        // set up the graph and nums array
        nums = nums_;
        for (auto& e : edges) {
            g[e[0]].push_back(e[1]);
            g[e[1]].push_back(e[0]);
        }

        // calculate xor of all subtrees rooted at each node, and by the way, store the parent node of each.
        // Use node 0 as root since it's guaranteed to exist in a tree with n nodes
        int total_xor = dfs(edges[0][0], -1);

        // confirm the first edge
        int m = edges.size();
        for (int i = 0; i < m; i++) {
            int u1 = edges[i][0], v1 = edges[i][1];
            int xor1;
            int start=v1;
            if (parent[v1] == u1) xor1 = subtreeXor[v1];    // the node u1 is the child of v1
            else {
                xor1 = subtreeXor[u1]; // the node v1 is the child of u1
                start=u1;
            }
            // confirm the second edge
            // case 1
            for(int v:g[start]){
                if(v==parent[start]) continue;
                dfs_sub1(v,total_xor,xor1);
                if(res==0) return 0; // if the result is zero, we can't form a valid component
            }

            // case 2
            int case2=start;
            while(parent[case2]>=0){
                int temp=case2;
                case2=parent[case2];
                for(int v:g[case2]){
                    if (v == parent[case2]||v==temp) continue; //jump over the parent node and visited node
                    dfs_sub2(v, total_xor, xor1);
                    if(res==0) return 0;
                }
            }
        }

        return res;
    }
};
```

## 基于DFS时间戳的优化解法（带详细注释）

这个解法使用DFS时间戳来判断祖先关系，避免了复杂的树遍历，是一个非常优雅的O(n²)解法：

```c++
class Solution {
public:
    int minimumScore(vector<int>& nums, vector<vector<int>>& edges) {
        int n = nums.size();
        
        // 构建邻接表
        vector<vector<int>> g(n);
        for (auto& e : edges) {
            int x = e[0], y = e[1];
            g[x].push_back(y);
            g[y].push_back(x);
        }

        // 关键数据结构：
        vector<int> xr(n);    // xr[i]: 以节点i为根的子树的异或值
        vector<int> in(n);    // in[i]: 节点i的DFS进入时间戳
        vector<int> out(n);   // out[i]: 节点i的DFS退出时间戳
        int clock = 0;        // 全局时间戳计数器
        
        // DFS计算子树异或值和时间戳
        // 使用C++23的递归lambda语法 this auto&&
        auto dfs = [&](this auto&& dfs, int x, int fa) -> void {
            in[x] = ++clock;     // 进入节点x的时间戳（递的过程）
            xr[x] = nums[x];     // 初始化为当前节点值
            
            // 遍历所有子节点
            for (int y : g[x]) {
                if (y != fa) {   // 跳过父节点
                    dfs(y, x);   // 递归处理子节点
                    xr[x] ^= xr[y]; // 累加子树异或值
                }
            }
            out[x] = clock;      // 退出节点x的时间戳（归的过程）
        };
        dfs(0, -1);

        // 关键函数：判断节点x是否为节点y的祖先
        // 原理：如果x是y的祖先，那么DFS访问x时，y一定在x的子树中被访问
        // 因此：in[x] < in[y] <= out[x]
        auto is_ancestor = [&](int x, int y) -> bool {
            return in[x] < in[y] && in[y] <= out[x];
        };

        int ans = INT_MAX;
        
        // 枚举所有可能的两条删除边
        // 删除边的表示：删除节点x与其父节点之间的边
        // 从节点1和2开始，因为节点0是根节点，没有父节点
        for (int x = 2; x < n; x++) {      // 第一条删除边：删除x与其父节点的连边
            for (int y = 1; y < x; y++) {  // 第二条删除边：删除y与其父节点的连边
                int a, b, c; // 三个连通组件的异OR值
                
                if (is_ancestor(x, y)) { 
                    // 情况1：x是y的祖先
                    // 删除边后的三个组件：
                    // - 组件a：以y为根的子树
                    // - 组件b：以x为根的子树减去以y为根的子树
                    // - 组件c：整棵树减去以x为根的子树
                    a = xr[y];                    // y子树的异或值
                    b = xr[x] ^ a;               // x子树减去y子树的异或值
                    c = xr[0] ^ xr[x];           // 剩余部分的异或值
                    
                } else if (is_ancestor(y, x)) { 
                    // 情况2：y是x的祖先（与情况1对称）
                    a = xr[x];                    // x子树的异或值
                    b = xr[y] ^ a;               // y子树减去x子树的异或值
                    c = xr[0] ^ xr[y];           // 剩余部分的异或值
                    
                } else { 
                    // 情况3：x和y分别属于两棵不相交的子树
                    // 删除边后的三个组件：
                    // - 组件a：以x为根的子树
                    // - 组件b：以y为根的子树
                    // - 组件c：剩余部分
                    a = xr[x];                    // x子树的异或值
                    b = xr[y];                    // y子树的异或值
                    c = xr[0] ^ a ^ b;           // 剩余部分的异或值
                }
                
                // 计算当前方案的分数（最大值-最小值）
                ans = min(ans, max({a, b, c}) - min({a, b, c}));
                
                // 优化：如果已经找到最优解，提前返回
                if (ans == 0) {
                    return 0;
                }
            }
        }
        return ans;
    }
};
```

### 算法核心思想：

1. **DFS时间戳技巧**：
   - `in[x]`：进入节点x的时间
   - `out[x]`：离开节点x的时间
   - 如果`in[x] < in[y] <= out[x]`，则x是y的祖先

2. **三种删边情况**：
   - **祖先关系**：一个节点是另一个的祖先，形成嵌套的子树分割
   - **无关系**：两个节点在不同的子树中，形成并列的子树分割

3. **异OR值计算**：
   - 利用异OR的性质：`A ^ B = C` 则 `A = C ^ B`
   - 通过子树异OR值的加减来快速计算分割后的组件值

### 时间复杂度：
- **预处理**：O(n) - DFS计算子树异OR值和时间戳
- **枚举**：O(n²) - 枚举所有节点对
- **总体**：O(n²)

### 空间复杂度：O(n)

这个解法的优势是代码简洁，逻辑清晰，避免了复杂的树遍历，是一个很好的参考实现！


