# 118. 杨辉三角

## 题目描述

给定一个非负整数 `numRows`，生成杨辉三角的前 `numRows` 行。

杨辉三角的性质：

- 每一行的首尾都是 1
- 除首尾外，每个数字都是上一行相邻两个数字之和
- 第 i 行有 i+1 个数字（从第0行开始计数）

**示例：**

```text
numRows = 5
     1
    1 1
   1 2 1
  1 3 3 1
 1 4 6 4 1
```

## 基本思路

**思路说明：**

1. 逐行构建杨辉三角
2. 每一行先添加首部的 1
3. 计算中间的数字（上一行相邻两数之和）
4. 最后添加尾部的 1

**时间复杂度：** O(numRows²)  
**空间复杂度：** O(1) - 不计算返回结果的空间

```c++
class Solution {
public:
    vector<vector<int>> generate(int numRows) {
        vector<vector<int>> res;
        for(int i=0;i<numRows;i++){
            vector<int> newLayer;
            newLayer.push_back(1);  // 每行首部添加1
            if(i==0){
                res.push_back(newLayer);
                continue;  // 第0行只有一个1
            }
            // 计算中间的数字：上一行相邻两数之和
            for(int j=0;j<i-1;j++){
                newLayer.push_back(res[i-1][j]+res[i-1][j+1]);
            }
            newLayer.push_back(1);  // 每行尾部添加1
            res.push_back(newLayer);
        }
        return res;
    }
};
```

## 优化解法

把杨辉三角的每一排左对齐：

[1]
[1,1]
[1,2,1]
[1,3,3,1]
[1,4,6,4,1]

**优化思路：**

1. **预分配空间**：直接创建 numRows 大小的二维数组
2. **resize初始化**：每行resize为对应大小，并初始化为1
3. **只计算中间值**：首尾已经是1，只需计算中间位置的值

**优点：**

- 减少了 push_back 操作的开销
- 代码更简洁，逻辑更清晰
- 避免了特殊情况的判断

**时间复杂度：** O(numRows²)  
**空间复杂度：** O(1) - 不计算返回结果的空间

```c++
class Solution {
public:
    vector<vector<int>> generate(int numRows) {
        vector<vector<int>> c(numRows);  // 预分配numRows行
        for (int i = 0; i < numRows; i++) {
            c[i].resize(i + 1, 1);  // 第i行有i+1个元素，全部初始化为1
            for (int j = 1; j < i; j++) {  // 只处理中间位置
                // 左上方的数 + 正上方的数
                c[i][j] = c[i - 1][j - 1] + c[i - 1][j];
            }
        }
        return c;
    }
};
```
