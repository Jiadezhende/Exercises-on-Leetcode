# 904. 水果成篮

## Description

You are visiting a farm that has a single row of fruit trees arranged from left to right. The trees are represented by an integer array `fruits` where `fruits[i]` is the type of fruit the ith tree produces.

You want to collect as much fruit as possible. However, the owner has some strict rules that you must follow:

- You only have two baskets, and each basket can only hold a single type of fruit. There is no limit on the amount of fruit each basket can hold.
- Starting from any tree of your choice, you must pick exactly one fruit from every tree (including the start tree) while moving to the right. The picked fruits must fit in one of your baskets.
- Once you reach a tree with fruit that cannot fit in your baskets, you must stop.

Given the integer array `fruits`, return the maximum maxFruitsber of fruits you can pick.

### Example 1

Input: `fruits = [1,2,1]`
Output: `3`
Explanation: We can pick from all 3 trees.

### Example 2

Input: `fruits = [0,1,2,2]`
Output: `3`
Explanation: We can pick from trees `[1,2,2]`.
If we had started at the first tree, we would only pick from trees `[0,1]`.

## Coding

### 解题思路

这个问题本质上是求**最多包含两种不同元素的最长子数组**，是一个典型的滑动窗口问题。

- 使用两个指针维护一个窗口，窗口内最多包含两种不同的水果类型
- 当遇到第三种水果时，需要缩小窗口直到只包含两种水果
- 记录过程中的最大窗口长度

### 方法一：滑动窗口 + 哈希表

```c++
class Solution {
public:
    int totalFruit(vector<int>& fruits) {
        if (fruits.empty()) return 0;
        
        unordered_map<int, int> basket; // 记录每种水果的数量
        int left = 0;    // 窗口左边界
        int maxFruits = 0; // 最大水果数量
        
        for (int right = 0; right < fruits.size(); right++) {
            // 将当前水果加入篮子
            basket[fruits[right]]++;
            
            // 如果篮子中水果种类超过2种，需要缩小窗口
            while (basket.size() > 2) {
                basket[fruits[left]]--;
                // 如果某种水果数量为0，从篮子中移除
                if (basket[fruits[left]] == 0) {
                    basket.erase(fruits[left]);
                }
                left++; // 缩小窗口
            }
            
            // 更新最大水果数量
            maxFruits = max(maxFruits, right - left + 1);
        }
        
        return maxFruits;
    }
};
```

### 方法二：优化的滑动窗口（基于位置记录）

ps：方案三更加合理且高效

```c++
class Solution {
public:
    int totalFruit(vector<int>& fruits) {
        if (fruits.empty()) return 0;
        // use 2 flags to maintain the last position of two types of fruits
        int fruit1=-1;
        int fruit2=fruits[0];
        int pos1=-1; //last fruit1, starting point for the loop
        int pos2=0; //last fruit2
        int maxFruits=0;
        int currentLength=0;
        int n=fruits.size();

        //  if there is a different f2.
        //  for the first loop, we assumed an invalid fruit1: -1, so that we can unify the logic.
        int i=pos2;
        while(i<n){
            if(fruits[i]==fruit2){
                currentLength++;
                pos2=i++;
                continue;
            }
            if(fruits[i]==fruit1){
                currentLength++;
                pos1=i++;
                continue;
            }
            maxFruits=max(maxFruits,currentLength);

            //遇到第三种水果，丢弃较远的那种
            if(pos1<pos2){
                fruit1=fruit2;
                currentLength=i-pos1;
                pos1=pos2;
            }else{
                currentLength=i-pos2;
            }
            fruit2=fruits[i];
            pos2=i++;
        }
        maxFruits=max(maxFruits,currentLength);
            
        return maxFruits;
        
    }
};
```

### 方法三：基于连续计数的滑动窗口

```c++
class Solution {
public:
    int totalFruit(vector<int>& fruits) {
        if (fruits.empty()) return 0;
        
        int fruit1 = -1, fruit2 = -1;    // 两种水果类型
        int count1 = 0, count2 = 0;      // 两种水果的连续计数
        int maxFruits = 0;               // 最大水果数量
        int currentLength = 0;           // 当前窗口长度
        
        for (int fruit : fruits) {
            if (fruit == fruit1 || fruit1 == -1) {
                // 遇到第一种水果（或初始化第一种水果）
                if (fruit1 == -1) fruit1 = fruit;
                count1++;
                count2 = 0;  // 重置第二种水果的连续计数
                currentLength++;
            } else if (fruit == fruit2 || fruit2 == -1) {
                // 遇到第二种水果（或初始化第二种水果）
                if (fruit2 == -1) fruit2 = fruit;
                count2++;
                count1 = 0;  // 重置第一种水果的连续计数
                currentLength++;
            } else {
                // 遇到第三种水果，需要重新开始
                // 保留最近连续的那种水果
                if (count1 > 0) {
                    // 最近的是fruit1，保留fruit1
                    fruit2 = fruit;
                    currentLength = count1 + 1;
                    count2 = 1;
                    count1 = 0;
                } else {
                    // 最近的是fruit2，保留fruit2
                    fruit1 = fruit2;
                    fruit2 = fruit;
                    currentLength = count2 + 1;
                    count1 = 0;
                    count2 = 1;
                }
            }
            
            maxFruits = max(maxFruits, currentLength);
        }
        
        return maxFruits;
    }
};
```

### 复杂度分析

**方法一：**

- 时间复杂度：O(n)，每个元素最多被访问两次
- 空间复杂度：O(1)，哈希表最多存储3个元素

**方法二 & 方法三：**

- 时间复杂度：O(n)，一次遍历
- 空间复杂度：O(1)，只使用常数额外空间

### 算法要点总结

1. **方法一**：标准滑动窗口 + 哈希表，逻辑清晰，容易理解
2. **方法二**：优化的滑动窗口，通过记录位置实现高效计算，合并循环使代码更简洁
3. **方法三**：基于连续计数的滑动窗口，记录每种水果的连续出现次数

**核心思想**：

- 维护一个最多包含两种不同水果的窗口
- 当遇到第三种水果时，保留最近连续出现的那种水果
- 重新开始计算窗口长度，确保连续性

**方法二的关键优化**：

- 使用 `pos1` 和 `pos2` 记录两种水果最后出现的位置
- 通过位置比较确定哪种水果更近，避免复杂的回溯逻辑
- 单循环处理，代码结构清晰简洁
- 当遇到第三种水果时，直接通过 `i - 丢弃位置` 计算新窗口长度，无需循环查找
- 核心公式：保留最近的水果，新窗口长度 = 当前位置 - 被丢弃水果的位置

**方法三的关键优化**：

- 使用 `count1` 和 `count2` 记录两种水果的连续出现次数
- 当遇到第三种水果时，通过比较哪个 count > 0 来确定最近出现的水果
- 避免了复杂的位置计算，逻辑更加简洁
