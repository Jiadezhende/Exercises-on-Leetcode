# 142. 直线上最多的点数
## 题目描述
给你一个数组 `points` ，其中 `points[i] = [xi, yi]` 表示 `X-Y` 平面上的一个点。求最多有多少个点在同一条直线上。

输入：`points = [[1,1],[2,2],[3,3]]`
输出：`3`

## Analysis
A line can be configured by two points.
So we should first select two points, then check how many points are on the line.
Let's define a tool function to check if a point is on the line.
```c++
// Check if three points are collinear using cross product
// Formula: (p1-p2) × (p1-p3) = 0, which expands to:
// (p1[0]-p2[0])*(p1[1]-p3[1]) == (p1[1]-p2[1])*(p1[0]-p3[0])
bool inLine(vector<int>& p1, vector<int>& p2, vector<int>& p3){
    return (p1[0]-p2[0])*(p1[1]-p3[1])==(p1[1]-p2[1])*(p1[0]-p3[0]);
}
```
***Use 3 loops to check all the situations***
Notice that we don't care about the visited points, because if it's on the line, the line must have been considered when we visited the point.

***3 loops, then the time complexity is O(n^3).***
```c++
// Main function to find maximum points on the same line
int maxPoints(vector<vector<int>>& points) {
    int num = points.size();
    int res;
    
    // Handle edge cases: if less than 3 points, all points are on the same line
    if(num < 3) res = num;
    else res = 2;  // Initialize result to 2 (minimum for 3+ points case)
    
    // Try every pair of points to form a line
    for(int i = 0; i < num; i++){
        for(int j = i + 1; j < num; j++){
            int max = 2;  // Start with 2 points (points[i] and points[j])
            
            // Check all remaining points to see if they lie on the same line
            for(int t = j + 1; t < num; t++){
                if(inLine(points[i], points[j], points[t])){
                    max++;  // Found another point on the same line
                }
            }
            
            // Update the global maximum if current line has more points
            if(max > res) res = max;
        }
    }
    return res;
}
```

## 事实上，减少函数调用，减少条件判断，本身就能优化用时：
```c++
class Solution {
public:
    int maxPoints(vector<vector<int>>& points) {
        int n = points.size();
        int ans = 1;
        for (int i = 0; i < n; ++i) {
            int x1 = points[i][0], y1 = points[i][1];
            for (int j = i + 1; j < n; ++j) {
                int x2 = points[j][0], y2 = points[j][1];
                int cnt = 2;
                for (int k = j + 1; k < n; ++k) {
                    int x3 = points[k][0], y3 = points[k][1];
                    int a = (y2 - y1) * (x3 - x1);
                    int b = (y3 - y1) * (x2 - x1);
                    cnt += a == b;
                }
                ans = max(ans, cnt);
            }
        }
        return ans;
    }
};
```

## 优化版本：使用哈希表优化到O(n²*log(m))

核心思想：对于每个点，计算它与其他点的斜率，相同斜率的点在同一条直线上。

```c++
class Solution {
public:
    int maxPoints(vector<vector<int>>& points) {
        int n = points.size();
        if (n <= 2) return n;
        
        int maxPoints = 2;
        
        // For each point, calculate slopes with all other points
        for (int i = 0; i < n; i++) {
            unordered_map<string, int> slopeCount; // slope -> count of points
            int duplicate = 1; // Count of points same as points[i]
            int verticalPoints = 0; // Count of points forming vertical line with points[i]
            
            for (int j = i + 1; j < n; j++) {
                int dx = points[j][0] - points[i][0];
                int dy = points[j][1] - points[i][1];
                
                if (dx == 0 && dy == 0) {
                    // Same point as points[i]
                    duplicate++;
                } else if (dx == 0) {
                    // Vertical line
                    verticalPoints++;
                } else {
                    // Calculate slope and store as reduced fraction
                    int gcd_val = gcd(abs(dx), abs(dy));
                    dx /= gcd_val;
                    dy /= gcd_val;
                    
                    // Normalize: make dx positive
                    if (dx < 0) {
                        dx = -dx;
                        dy = -dy;
                    }
                    
                    string slope = to_string(dy) + "/" + to_string(dx);
                    slopeCount[slope]++;
                }
            }
            
            // Update maximum: consider duplicate points
            maxPoints = max(maxPoints, duplicate + verticalPoints);
            
            for (auto& [slope, count] : slopeCount) {
                maxPoints = max(maxPoints, duplicate + count);
            }
        }
        
        return maxPoints;
    }
    
private:
    // Calculate Greatest Common Divisor
    int gcd(int a, int b) {
        return b == 0 ? a : gcd(b, a % b);
    }
};
```

### 算法优化要点：

1. **斜率表示**：使用最简分数形式 `dy/dx` 避免浮点数精度问题
2. **特殊情况处理**：
   - 相同点：`duplicate` 计数器
   - 垂直线：`dx = 0` 单独处理
3. **分数标准化**：
   - 使用GCD约简到最简分数
   - 保证分母为正数统一表示
4. **哈希表**：`slope -> count` 记录每种斜率对应的点数

### 时间复杂度分析：
- **优化前**：O(n³) - 三重循环
- **优化后**：O(n²*log(m)) - 两重循环，斜率计算和存储为最简分数需要O(log(m))

### 关键改进：
- 从"枚举每对点形成直线"变为"枚举每个点计算斜率"
- 用哈希表快速统计相同斜率的点数
- 避免了第三层循环的点共线判断

这个优化版本在处理大规模数据时会有显著的性能提升！
